# GitHub 仓库批量克隆脚本

**批量克隆 GitHub 仓库**，采用**双重并行加速**技术（应用层多仓库并发 + Git 层多连接传输），大幅提升克隆速度。结合独特的**军事高地编号体系**，实现仓库的智能分类与高效管理。

## 一、🚀 快速开始

1. **安装 GitHub CLI**（如果未安装）：
   ```bash
   # Windows (使用 Chocolatey)
   choco install gh
   
   # macOS (使用 Homebrew)
   brew install gh
   
   # Linux
   # 参考: https://cli.github.com/
   ```

2. **登录认证**：
   ```bash
   gh auth login
   ```

3. **创建分类文档**（使用 AI 辅助）：
   - 打开 `GitHub 仓库分类 Prompt.md`
   - 在 Cursor 中执行：`@GitHub 仓库分类 Prompt.md 执行当前prompt`
   - 确认后保存为 `REPO-GROUPS.md`

4. **开始同步**：
   ```bash
   bash sync-groups-v2.sh
   ```

## 二、🎯 核心特点

### 🚀 一键批量克隆
**核心功能**：自动扫描所有分组，批量克隆所有缺失的仓库，无需手动逐个操作。

### ⚡ 双重并行加速
**性能优势**：应用层并行（同时克隆多个仓库，默认 5 并发）+ Git 层并行传输（每个仓库多连接，默认 8 连接），双重叠加充分利用网络带宽，大幅提升克隆速度。

### 🎯 智能浅克隆
**空间优化**：超过 300MB 的仓库自动使用浅克隆（`--depth 1`），仅克隆最新提交。
- **历史长仓库（10年以上）**：可减少 80-90% 的存储空间和克隆时间（例如：500MB → 50MB）
- **新仓库（几个月历史）**：可减少 10-20% 的空间
- **智能决策**：300MB 阈值在节省空间和保留历史之间取得平衡

### 🔄 自动重试机制
**可靠性保障**：每个仓库克隆失败后立即重试 3 次（带间隔），失败后自动清理不完整目录，确保克隆过程的可靠性。

### 📁 高效组织管理
**清晰结构**：每个分组自动创建独立文件夹（格式：`组名 (高地编号)`），所有仓库按分组清晰组织。

### ⚔️ 军事高地编号体系
**独特特色**：使用历史上著名高地编号（如 `597.9高地`、`382高地`）作为分组代号，以"攻占高地"的心态专注管理项目，增强记忆和识别度。

## 三、⚙️ 自定义参数

**灵活配置**：脚本已内置针对高带宽环境的 Git 优化参数和并发参数，你可以根据实际需求自定义这些参数以优化性能。

### 3.1 Git 网络参数自定义

**默认优化参数**：

| 参数 | Git 默认值 | 脚本优化值 | 说明 |
|------|-----------|-----------|------|
| `http.postBuffer` | 1MB | **500MB** | 增加 HTTP POST 缓冲区，减少网络往返次数，提升大仓库传输效率 |
| `http.lowSpeedLimit` | 1000 bytes/s | **0** | 禁用低速传输检测，避免高速网络被误判 |
| `http.lowSpeedTime` | 30秒 | **0** | 禁用低速传输超时，避免高速网络被误判 |
| `http.version` | HTTP/1.1 | **HTTP/2** | 使用 HTTP/2 协议，支持多路复用，更高效利用带宽 |
| `pack.windowMemory` | 256MB | **1GB** | 增加 pack 窗口内存，提升压缩和传输效率 |
| `pack.threads` | 自动 | **CPU核心数** | 显式使用多线程，充分利用多核 CPU 加速压缩和解压 |
| `core.compression` | 6 | **1** | 降低压缩级别（速度优先），在高速网络下减少压缩时间瓶颈 |

**优化效果**：这些配置可以显著提升克隆速度，特别是在高带宽（> 50Mbps）环境下效果明显。

**自定义参数方法**：

1. **修改脚本变量**（推荐）：编辑 `lib/github-api-query.sh`，修改以下变量：
   ```bash
   readonly GIT_POST_BUFFER_SIZE=524288000      # HTTP POST 缓冲区大小（500MB）
   readonly GIT_PACK_WINDOW_MEMORY=1073741824   # Pack 窗口内存（1GB）
   readonly GIT_DEFAULT_CPU_CORES=4             # 默认 CPU 核心数
   ```

2. **使用 Git 全局配置**：直接使用 `git config` 命令自定义：
   ```bash
   git config --global http.postBuffer 524288000
   git config --global pack.windowMemory 1073741824
   git config --global pack.threads 8
   git config --global core.compression 1
   ```

### 3.2 并发参数自定义

#### 推荐配置

根据你的网络带宽选择合适的配置：

- **低带宽（< 10Mbps）**：`-t 3-5 -c 4-8`
- **中带宽（10-50Mbps）**：`-t 5-10 -c 8-12`
- **高带宽（50-200Mbps）**：`-t 10-15 -c 16-24`
- **超高带宽（> 200Mbps，如 300Mbps）**：`-t 15-20 -c 24-32`

#### 性能优化案例参考（300Mbps 带宽）

**环境信息**：
- 网络带宽：300Mbps
- 理论极限速度：约 40MB/s
- 默认配置速度：约 12MB/s（稳定）

**优化方案**（按推荐顺序测试）：

**方案一：保守优化（推荐首次使用）**
```bash
bash sync-groups-v2.sh -t 12 -c 20
```
- **预期效果**：速度提升至 18-22MB/s
- **特点**：稳定可靠，资源占用适中
- **适用场景**：首次优化测试，追求稳定性

**方案二：激进优化（方案一效果良好时使用）**
```bash
bash sync-groups-v2.sh -t 15 -c 24
```
- **预期效果**：速度提升至 25-30MB/s
- **特点**：性能提升明显，资源占用较高
- **适用场景**：方案一效果不错，想进一步提升速度

**方案三：极限优化（追求极致性能）**
```bash
bash sync-groups-v2.sh -t 18 -c 28
```
- **预期效果**：速度接近或达到 35-40MB/s（接近理论极限）
- **特点**：性能最大化，资源占用高
- **适用场景**：系统资源充足，追求极致速度

**测试建议**：
1. 按顺序测试：先试方案一，稳定后再试方案二，最后尝试方案三
2. 监控系统资源：观察 CPU、内存、网络使用率
3. 记录实际效果：观察克隆完成时间和系统资源占用情况

### 3.3 常见问题与注意事项

**1. 连接超时或错误**

**症状**：克隆过程中出现连接超时、连接重置等错误

**可能原因**：
- 并行连接数过多，超过服务器限制
- 网络不稳定
- 防火墙或代理限制

**解决方法**：
- 降低并行传输数（`-c` 参数）：从 28 降到 24 或 20
- 降低并行任务数（`-t` 参数）：从 18 降到 15 或 12
- 检查网络连接稳定性
- 如果使用代理，检查代理配置

**2. CPU 或内存占用过高**

**症状**：系统卡顿，CPU 或内存使用率接近 100%

**解决方法**：
- 降低并行任务数（`-t` 参数）：减少同时克隆的仓库数量
- 降低并行传输数（`-c` 参数）：减少每个仓库的连接数
- 关闭其他占用资源的程序

**3. 速度未达到预期**

**可能原因**：
- 网络带宽实际低于预期
- GitHub 服务器限流
- 本地磁盘 I/O 成为瓶颈
- 仓库大小差异较大

**解决方法**：
- 检查网络带宽是否真的达到标称值
- 尝试不同时间段运行（避开高峰期）
- 检查磁盘读写速度（SSD 通常更快）
- 观察克隆完成时间，评估实际性能

**4. 部分仓库克隆失败**

**症状**：部分仓库克隆失败，但其他仓库成功

**解决方法**：
- 脚本会自动重试 3 次，通常能自动恢复
- 如果持续失败，检查该仓库是否真的存在
- 检查是否有权限访问该仓库
- 查看错误日志，确认具体错误原因

**5. 克隆速度较慢**

**可能原因**：
- 网络带宽实际低于预期
- GitHub 服务器限流
- 本地磁盘 I/O 成为瓶颈
- 并行参数设置过低

**解决方法**：
- 检查网络带宽是否真的达到标称值
- 尝试不同时间段运行（避开高峰期）
- 检查磁盘读写速度（SSD 通常更快）
- 根据网络带宽调整 `-t` 和 `-c` 参数（参考推荐配置）

**优化建议总结**：
- ✅ 从保守配置开始，逐步提升
- ✅ 监控系统资源，避免过载
- ✅ 观察克隆完成时间，找到最佳配置
- ✅ 根据实际情况调整，不要盲目追求高参数
- ✅ 优先保证稳定性，再追求速度

**文件夹组织**：每个分组会自动创建对应的文件夹（格式：`组名 (高地编号)`，如 `Go-Practice (397.8号高地)`），该分组下的所有仓库会同步到对应的文件夹中，实现清晰的组织结构。


---

## 四、📐 架构设计

### 核心设计原则

1. **单一职责**: 纯克隆工具，只负责批量克隆，不处理更新和删除
2. **全局性处理**: 先全局扫描所有差异，找出缺失的仓库，再统一执行克隆
3. **并行处理**: 默认并行处理，同时克隆多个仓库（默认 5 并发，可通过 `-t` 参数配置）
4. **并行传输**: 每个仓库克隆时使用多个连接（默认 8 连接，可通过 `-c` 参数配置，需要 Git 2.32+）
5. **智能重试**: 每个仓库失败后立即重试3次（带间隔），失败后自动清理不完整目录
6. **缓存优化**: 所有数据一次性加载到内存，避免重复 I/O 和 API 调用

### 主要工作流程

#### 完整执行流程（7个步骤）

```
开始 (main.sh)
  │
  ├─→ [1] 解析命令行参数
  │     └─ parse_args() [main.sh]
  │         ├─ 解析 -t 参数（并行任务数，默认 5）
  │         └─ 解析 -c 参数（并行传输数，默认 8）
  │
  ├─→ [2] 初始化克隆环境
  │     └─ initialize_sync() [sync-orchestration.sh]
  │         ├─ 检查配置文件存在性
  │         ├─ 创建 repos 目录
  │         ├─ 初始化 GitHub 连接 [github-api-query.sh]
  │         └─ 初始化统计变量 [stats.sh]
  │
  ├─→ [3] 初始化缓存系统
  │     ├─ init_config_cache() [cache.sh]
  │     │   └─ 解析 REPO-GROUPS.md，建立分组缓存
  │     └─ init_repo_cache() [cache.sh]
  │         └─ 批量获取所有远程仓库，建立名称映射
  │
  ├─→ [4] 获取所有分组用于克隆
  │     └─ get_all_group_names() [config.sh]
  │         └─ 从缓存中获取所有分组名称
  │
  ├─→ [5] 全局扫描差异，找出缺失的仓库
  │     └─ scan_global_diff() [diff-analysis.sh]
  │         ├─ 遍历所有分组和仓库
  │         ├─ 检查每个仓库的本地状态（检查 .git 目录）
  │         ├─ 获取每个缺失仓库的大小（用于统计和浅克隆决策）
  │         ├─ 分类：缺失 / 已存在（跳过）/ 跳过 / 不存在
  │         ├─ 显示仓库大小统计（总大小、大仓库列表等）
  │         └─ 存储到全局数组：
  │             ├─ global_repos_to_clone (缺失的，需要克隆的)
  │             └─ global_repo_sizes (仓库大小信息，用于浅克隆决策)
  │
  ├─→ [6] 执行批量克隆（并行处理）
  │     └─ execute_sync() [sync-orchestration.sh]
  │         ├─ 从 global_repos_to_clone 收集所有需要克隆的仓库
  │         ├─ 构建任务数组（格式：repo_full|repo_name|group_folder|group_name|global_index）
  │         └─ 并行执行克隆：
  │             └─ execute_parallel_repo_tasks() [sync-orchestration.sh]
  │                 └─ 并行调用 clone_repo() [repo-clone-update.sh]
  │                     ├─ 智能浅克隆：超过 300MB 的仓库自动使用 --depth 1
  │                     │   ├─ 历史长仓库（10年以上、大量提交）：效果显著，减少 80-90% 空间和时间
  │                     │   └─ 新仓库（几个月历史、少量提交）：效果有限，减少 10-20% 空间
  │                     ├─ 重试机制：失败后立即重试3次（间隔3秒）
  │                     ├─ 协议选择：优先 SSH，失败回退到 HTTPS
  │                     ├─ 并行传输：使用 --jobs 参数（默认 8 个连接）
  │                     └─ 自动清理：失败后删除不完整的目录
  │
  └─→ [7] 输出最终统计
        └─ print_final_summary() [stats.sh]
            ├─ 显示成功/失败统计
            └─ 显示耗时统计
```

### 模块化架构

```
main.sh (主入口)
  │
  ├── lib/logger.sh (日志输出)
  ├── lib/utils.sh (工具函数)
  ├── lib/progress.sh (进度显示)
  ├── lib/config.sh (配置解析)
  ├── lib/cache.sh (缓存初始化)
  ├── lib/github-api-query.sh (GitHub API 查询 - 包含仓库大小查询)
  ├── lib/repo-clone-update.sh (仓库克隆操作 - 包含智能浅克隆)
  ├── lib/stats.sh (统计报告)
  ├── lib/diff-analysis.sh (差异分析 - 只检查缺失，包含大小统计)
  └── lib/sync-orchestration.sh (克隆编排)
```

**模块依赖关系**: logger/utils/progress → config/cache/github-api-query → repo-clone-update/stats/diff-analysis → sync-orchestration → main

**文件结构**: `main.sh` + `lib/*.sh` (11 个模块，总计 1484 行)

**核心函数**:
- `scan_global_diff()`: 扫描差异，找出缺失的仓库，获取仓库大小并显示统计
- `execute_sync()`: 执行批量克隆操作
- `clone_repo()`: 克隆单个仓库（智能浅克隆、带重试和清理）
- `get_repo_size()`: 获取仓库大小（KB），带缓存优化
- `format_repo_size()`: 格式化仓库大小显示（MB/GB）
- `execute_parallel_repo_tasks()`: 并行执行克隆任务
- `update_sync_statistics()`: 更新统计信息（成功/失败计数）
- `print_final_summary()`: 输出最终统计（成功/失败统计和耗时统计）

### 代码统计

#### 主要代码文件列表

| 文件 | 行数 | 功能说明 |
|------|------|----------|
| `main.sh` | 167 | **主入口**：解析命令行参数、初始化环境、协调各模块执行 |
| `lib/sync-orchestration.sh` | 235 | **克隆编排模块**：初始化克隆环境、执行批量克隆操作、并行任务管理 |
| `lib/diff-analysis.sh` | 228 | **差异分析模块**：全局扫描差异，找出缺失的仓库（只检查缺失，不检查更新） |
| `lib/repo-clone-update.sh` | 221 | **仓库克隆操作模块**：克隆仓库（带自动重试和清理不完整目录）、协议选择（SSH/HTTPS）、智能浅克隆 |
| `lib/cache.sh` | 143 | **缓存初始化模块**：初始化配置文件缓存、仓库名称缓存 |
| `lib/github-api-query.sh` | 160 | **GitHub API 查询模块**：获取 GitHub 用户名、初始化 GitHub 连接、查找仓库完整名称、获取仓库大小、格式化大小显示 |
| `lib/logger.sh` | 123 | **日志输出模块**：提供统一的日志输出功能（info/warning/error/success）、API 调用日志（带计时） |
| `lib/config.sh` | 97 | **配置解析模块**：解析配置文件、获取分组信息、高地编号管理 |
| `lib/stats.sh` | 66 | **统计和报告模块**：初始化统计变量、更新统计信息（成功/失败计数）、输出最终统计报告（成功/失败统计和耗时统计） |
| `lib/progress.sh` | 30 | **进度显示模块**：提供简单的进度输出功能（带颜色） |
| `lib/utils.sh` | 14 | **工具函数模块**：提供字符串和数组转换的通用工具函数 |
| **总计** | **1484** | **11 个文件** |
